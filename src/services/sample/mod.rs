// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(clippy::all, unknown_lints, unused, non_snake_case)]

pub use schema::*;

pub mod protocol {
    pub fn protocol() -> ::lavish::Protocol<super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results> { ::lavish::Protocol::new() }
    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Params {
        GetCookies(super::schema::get_cookies::Params),
        Reverse(super::schema::reverse::Params),
        GetUserAgent(super::schema::get_user_agent::Params),
        Ping_Ping(super::schema::ping::ping::Params),
        Ping(super::schema::ping::Params),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Params),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Params),
        Session_Login(super::schema::session::login::Params),
    }
    impl ::lavish::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::GetCookies(_) => "get_cookies",
                Params::Reverse(_) => "reverse",
                Params::GetUserAgent(_) => "get_user_agent",
                Params::Ping_Ping(_) => "ping.ping",
                Params::Ping(_) => "ping",
                Params::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Params::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Params::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Params::GetCookies(__DS::<super::schema::get_cookies::Params>(de)?)),
                "reverse" => 
                    Ok(Params::Reverse(__DS::<super::schema::reverse::Params>(de)?)),
                "get_user_agent" => 
                    Ok(Params::GetUserAgent(__DS::<super::schema::get_user_agent::Params>(de)?)),
                "ping.ping" => 
                    Ok(Params::Ping_Ping(__DS::<super::schema::ping::ping::Params>(de)?)),
                "ping" => 
                    Ok(Params::Ping(__DS::<super::schema::ping::Params>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Params::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Params>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Params::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Params>(de)?)),
                "session.login" => 
                    Ok(Params::Session_Login(__DS::<super::schema::session::login::Params>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Results {
        GetCookies(super::schema::get_cookies::Results),
        Reverse(super::schema::reverse::Results),
        GetUserAgent(super::schema::get_user_agent::Results),
        Ping_Ping(super::schema::ping::ping::Results),
        Ping(super::schema::ping::Results),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Results),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Results),
        Session_Login(super::schema::session::login::Results),
    }
    impl ::lavish::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::GetCookies(_) => "get_cookies",
                Results::Reverse(_) => "reverse",
                Results::GetUserAgent(_) => "get_user_agent",
                Results::Ping_Ping(_) => "ping.ping",
                Results::Ping(_) => "ping",
                Results::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Results::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Results::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Results::GetCookies(__DS::<super::schema::get_cookies::Results>(de)?)),
                "reverse" => 
                    Ok(Results::Reverse(__DS::<super::schema::reverse::Results>(de)?)),
                "get_user_agent" => 
                    Ok(Results::GetUserAgent(__DS::<super::schema::get_user_agent::Results>(de)?)),
                "ping.ping" => 
                    Ok(Results::Ping_Ping(__DS::<super::schema::ping::ping::Results>(de)?)),
                "ping" => 
                    Ok(Results::Ping(__DS::<super::schema::ping::Results>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Results::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Results>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Results::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Results>(de)?)),
                "session.login" => 
                    Ok(Results::Session_Login(__DS::<super::schema::session::login::Results>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum NotificationParams {}
    impl ::lavish::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            panic!("no variants for NotificationParams")
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    pub type Client = ::lavish::Client<super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;
    pub type Handler = ::lavish::Handler<super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;
}

pub mod schema {
    #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
    pub struct Cookie {
        /// The key of the cookie
        pub key: String,
        /// The value of the cookie.
        /// Although it's typed as a string, it can be anything underneath.
        pub value: String,
    }
    pub mod get_cookies {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub cookies: Vec<super::Cookie>,
        }
    }
    pub mod reverse {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
            pub s: String,
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub s: String,
        }
    }
    pub mod get_user_agent {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub user_agent: String,
        }
    }
    pub mod ping {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
        }

        pub mod ping {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }
        }
        pub mod client {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
                on_ping__ping: Slot<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_ping__ping: None,
                    }
                }
                pub fn on_ping__ping<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::ping::ping::Params>) -> Result<super::super::super::schema::ping::ping::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_ping__ping = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Ping_Ping(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Ping_Ping)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Ping_Ping(_) => self.on_ping__ping.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::client::Client { root },
                        params,
                    };
                    slot(call)
                }
            }
        }

        pub mod server {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
                pub fn ping(&self, p: super::super::super::schema::ping::ping::Params) -> Result<super::super::super::schema::ping::ping::Results, ::lavish::Error> {
                    self.root.call(
                        super::super::super::protocol::Params::Ping_Ping(p),
                        |r| match r {
                            super::super::super::protocol::Results::Ping_Ping(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
            }
        }

    }
    pub mod universe {
        pub mod earth {
            pub mod country {
                pub mod city {
                    pub mod new_york {
                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Params {
                        }

                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Results {
                        }
                    }
                    pub mod client {
                        pub struct Client {
                            root: super::super::super::super::super::super::protocol::Client,
                        }

                        impl Client {
                            pub fn new(root: super::super::super::super::super::super::protocol::Client) -> Self {
                                Self { root }
                            }
                            pub fn new_york(&self, p: super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                                self.root.call(
                                    super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                                    |r| match r {
                                        super::super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                        _ => None,
                                    }
                                )
                            }
                        }
                        pub struct Call<T, P> {
                            pub state: ::std::sync::Arc<T>,
                            pub client: super::client::Client,
                            pub params: P,
                        }

                        impl<T, P> Call<T, P> {
                            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                            where
                                F: Fn(P) -> Option<PP>,
                            {
                                Ok(Call {
                                    state: self.state,
                                    client: self.client,
                                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                                })
                            }
                        }
                        pub type SlotReturn = Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error>;
                        pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                        pub type Slot<T> = Option<Box<SlotFn<T>>>;
                        pub struct Handler<T> {
                            state: std::sync::Arc<T>,
                        }

                        impl<T> Handler<T> {
                            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                                Self {
                                    state,
                                }
                            }
                        }
                        impl<T> ::lavish::Handler<super::super::super::super::super::super::protocol::Params, super::super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::super::protocol::Results> for Handler<T>
                        where
                            T: Send + Sync,
                        {
                            fn handle(&self, root: super::super::super::super::super::super::protocol::Client, params: super::super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error> {
                                use ::lavish::Atom;
                                Err(::lavish::Error::MethodUnimplemented(params.method()))
                            }
                        }
                    }

                    pub mod server {
                        pub struct Client {
                            root: super::super::super::super::super::super::protocol::Client,
                        }

                        impl Client {
                            pub fn new(root: super::super::super::super::super::super::protocol::Client) -> Self {
                                Self { root }
                            }
                        }
                        pub struct Call<T, P> {
                            pub state: ::std::sync::Arc<T>,
                            pub client: super::server::Client,
                            pub params: P,
                        }

                        impl<T, P> Call<T, P> {
                            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                            where
                                F: Fn(P) -> Option<PP>,
                            {
                                Ok(Call {
                                    state: self.state,
                                    client: self.client,
                                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                                })
                            }
                        }
                        pub type SlotReturn = Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error>;
                        pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                        pub type Slot<T> = Option<Box<SlotFn<T>>>;
                        pub struct Handler<T> {
                            state: std::sync::Arc<T>,
                            on_universe__earth__country__city__new_york: Slot<T>,
                        }

                        impl<T> Handler<T> {
                            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                                Self {
                                    state,
                                    on_universe__earth__country__city__new_york: None,
                                }
                            }
                            pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                            where
                                F: Fn(Call<T, super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                            {
                                self.on_universe__earth__country__city__new_york = Some(Box::new(
                                    move |call| {
                                        let call = call.downcast(|p| match p {
                                            super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                            _ => None,
                                        })?;
                                        f(call).map(super::super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                                    }
                                ));
                            }
                        }
                        impl<T> ::lavish::Handler<super::super::super::super::super::super::protocol::Params, super::super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::super::protocol::Results> for Handler<T>
                        where
                            T: Send + Sync,
                        {
                            fn handle(&self, root: super::super::super::super::super::super::protocol::Client, params: super::super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error> {
                                use ::lavish::Atom;
                                let slot = match params {
                                    super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                                    _ => None,
                                }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                                let call = Call {
                                    state: self.state.clone(),
                                    client: super::server::Client { root },
                                    params,
                                };
                                slot(call)
                            }
                        }
                    }

                }
                pub mod client {
                    pub struct Client {
                        root: super::super::super::super::super::protocol::Client,
                    }

                    impl Client {
                        pub fn new(root: super::super::super::super::super::protocol::Client) -> Self {
                            Self { root }
                        }
                        pub fn new_york(&self, p: super::super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                            self.root.call(
                                super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                                |r| match r {
                                    super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                    _ => None,
                                }
                            )
                        }
                    }
                    pub struct Call<T, P> {
                        pub state: ::std::sync::Arc<T>,
                        pub client: super::client::Client,
                        pub params: P,
                    }

                    impl<T, P> Call<T, P> {
                        fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                        where
                            F: Fn(P) -> Option<PP>,
                        {
                            Ok(Call {
                                state: self.state,
                                client: self.client,
                                params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                            })
                        }
                    }
                    pub type SlotReturn = Result<super::super::super::super::super::protocol::Results, ::lavish::Error>;
                    pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                    pub type Slot<T> = Option<Box<SlotFn<T>>>;
                    pub struct Handler<T> {
                        state: std::sync::Arc<T>,
                    }

                    impl<T> Handler<T> {
                        pub fn new(state: ::std::sync::Arc<T>) -> Self {
                            Self {
                                state,
                            }
                        }
                    }
                    impl<T> ::lavish::Handler<super::super::super::super::super::protocol::Params, super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::protocol::Results> for Handler<T>
                    where
                        T: Send + Sync,
                    {
                        fn handle(&self, root: super::super::super::super::super::protocol::Client, params: super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::protocol::Results, ::lavish::Error> {
                            use ::lavish::Atom;
                            Err(::lavish::Error::MethodUnimplemented(params.method()))
                        }
                    }
                }

                pub mod server {
                    pub struct Client {
                        root: super::super::super::super::super::protocol::Client,
                    }

                    impl Client {
                        pub fn new(root: super::super::super::super::super::protocol::Client) -> Self {
                            Self { root }
                        }
                    }
                    pub struct Call<T, P> {
                        pub state: ::std::sync::Arc<T>,
                        pub client: super::server::Client,
                        pub params: P,
                    }

                    impl<T, P> Call<T, P> {
                        fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                        where
                            F: Fn(P) -> Option<PP>,
                        {
                            Ok(Call {
                                state: self.state,
                                client: self.client,
                                params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                            })
                        }
                    }
                    pub type SlotReturn = Result<super::super::super::super::super::protocol::Results, ::lavish::Error>;
                    pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                    pub type Slot<T> = Option<Box<SlotFn<T>>>;
                    pub struct Handler<T> {
                        state: std::sync::Arc<T>,
                        on_universe__earth__country__city__new_york: Slot<T>,
                    }

                    impl<T> Handler<T> {
                        pub fn new(state: ::std::sync::Arc<T>) -> Self {
                            Self {
                                state,
                                on_universe__earth__country__city__new_york: None,
                            }
                        }
                        pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                        where
                            F: Fn(Call<T, super::super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                        {
                            self.on_universe__earth__country__city__new_york = Some(Box::new(
                                move |call| {
                                    let call = call.downcast(|p| match p {
                                        super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                        _ => None,
                                    })?;
                                    f(call).map(super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                                }
                            ));
                        }
                    }
                    impl<T> ::lavish::Handler<super::super::super::super::super::protocol::Params, super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::protocol::Results> for Handler<T>
                    where
                        T: Send + Sync,
                    {
                        fn handle(&self, root: super::super::super::super::super::protocol::Client, params: super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::protocol::Results, ::lavish::Error> {
                            use ::lavish::Atom;
                            let slot = match params {
                                super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                                _ => None,
                            }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                            let call = Call {
                                state: self.state.clone(),
                                client: super::server::Client { root },
                                params,
                            };
                            slot(call)
                        }
                    }
                }

            }
            pub mod client {
                pub struct Client {
                    root: super::super::super::super::protocol::Client,
                }

                impl Client {
                    pub fn new(root: super::super::super::super::protocol::Client) -> Self {
                        Self { root }
                    }
                    pub fn new_york(&self, p: super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                        self.root.call(
                            super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                            |r| match r {
                                super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                _ => None,
                            }
                        )
                    }
                }
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::client::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T> {
                    state: std::sync::Arc<T>,
                }

                impl<T> Handler<T> {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                        }
                    }
                }
                impl<T> ::lavish::Handler<super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync,
                {
                    fn handle(&self, root: super::super::super::super::protocol::Client, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        Err(::lavish::Error::MethodUnimplemented(params.method()))
                    }
                }
            }

            pub mod server {
                pub struct Client {
                    root: super::super::super::super::protocol::Client,
                }

                impl Client {
                    pub fn new(root: super::super::super::super::protocol::Client) -> Self {
                        Self { root }
                    }
                }
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::server::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T> {
                    state: std::sync::Arc<T>,
                    on_universe__earth__country__city__new_york: Slot<T>,
                }

                impl<T> Handler<T> {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                            on_universe__earth__country__city__new_york: None,
                        }
                    }
                    pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                    where
                        F: Fn(Call<T, super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                    {
                        self.on_universe__earth__country__city__new_york = Some(Box::new(
                            move |call| {
                                let call = call.downcast(|p| match p {
                                    super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                    _ => None,
                                })?;
                                f(call).map(super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                            }
                        ));
                    }
                }
                impl<T> ::lavish::Handler<super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync,
                {
                    fn handle(&self, root: super::super::super::super::protocol::Client, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        let slot = match params {
                            super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                            _ => None,
                        }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                        let call = Call {
                            state: self.state.clone(),
                            client: super::server::Client { root },
                            params,
                        };
                        slot(call)
                    }
                }
            }

        }
        pub mod client {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
                pub fn new_york(&self, p: super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                    self.root.call(
                        super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                        |r| match r {
                            super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
            }
        }

        pub mod server {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
                on_universe__earth__country__city__new_york: Slot<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_universe__earth__country__city__new_york: None,
                    }
                }
                pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_universe__earth__country__city__new_york = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::server::Client { root },
                        params,
                    };
                    slot(call)
                }
            }
        }

    }
    pub mod session {
        pub mod login {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
                pub username: String,
                pub password: String,
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }

            pub mod solve_totp {
                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Params {
                }

                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Results {
                    pub result: String,
                }
            }
            pub mod client {
                pub struct Client {
                    root: super::super::super::super::protocol::Client,
                }

                impl Client {
                    pub fn new(root: super::super::super::super::protocol::Client) -> Self {
                        Self { root }
                    }
                }
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::client::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T> {
                    state: std::sync::Arc<T>,
                    on_session__login__solve_totp: Slot<T>,
                }

                impl<T> Handler<T> {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                            on_session__login__solve_totp: None,
                        }
                    }
                    pub fn on_session__login__solve_totp<F>(&mut self, f: F)
                    where
                        F: Fn(Call<T, super::super::super::super::schema::session::login::solve_totp::Params>) -> Result<super::super::super::super::schema::session::login::solve_totp::Results, ::lavish::Error> + Send + Sync + 'static,
                    {
                        self.on_session__login__solve_totp = Some(Box::new(
                            move |call| {
                                let call = call.downcast(|p| match p {
                                    super::super::super::super::protocol::Params::Session_Login_SolveTotp(p) => Some(p),
                                    _ => None,
                                })?;
                                f(call).map(super::super::super::super::protocol::Results::Session_Login_SolveTotp)
                            }
                        ));
                    }
                }
                impl<T> ::lavish::Handler<super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync,
                {
                    fn handle(&self, root: super::super::super::super::protocol::Client, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        let slot = match params {
                            super::super::super::super::protocol::Params::Session_Login_SolveTotp(_) => self.on_session__login__solve_totp.as_ref(),
                            _ => None,
                        }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                        let call = Call {
                            state: self.state.clone(),
                            client: super::client::Client { root },
                            params,
                        };
                        slot(call)
                    }
                }
            }

            pub mod server {
                pub struct Client {
                    root: super::super::super::super::protocol::Client,
                }

                impl Client {
                    pub fn new(root: super::super::super::super::protocol::Client) -> Self {
                        Self { root }
                    }
                    pub fn solve_totp(&self, p: super::super::super::super::schema::session::login::solve_totp::Params) -> Result<super::super::super::super::schema::session::login::solve_totp::Results, ::lavish::Error> {
                        self.root.call(
                            super::super::super::super::protocol::Params::Session_Login_SolveTotp(p),
                            |r| match r {
                                super::super::super::super::protocol::Results::Session_Login_SolveTotp(r) => Some(r),
                                _ => None,
                            }
                        )
                    }
                }
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::server::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T> {
                    state: std::sync::Arc<T>,
                }

                impl<T> Handler<T> {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                        }
                    }
                }
                impl<T> ::lavish::Handler<super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync,
                {
                    fn handle(&self, root: super::super::super::super::protocol::Client, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        Err(::lavish::Error::MethodUnimplemented(params.method()))
                    }
                }
            }

        }
        pub mod client {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
                pub fn login(&self, p: super::super::super::schema::session::login::Params) -> Result<super::super::super::schema::session::login::Results, ::lavish::Error> {
                    self.root.call(
                        super::super::super::protocol::Params::Session_Login(p),
                        |r| match r {
                            super::super::super::protocol::Results::Session_Login(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
            }
        }

        pub mod server {
            pub struct Client {
                root: super::super::super::protocol::Client,
            }

            impl Client {
                pub fn new(root: super::super::super::protocol::Client) -> Self {
                    Self { root }
                }
            }
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
                on_session__login: Slot<T>,
            }

            impl<T> Handler<T> {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_session__login: None,
                    }
                }
                pub fn on_session__login<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::session::login::Params>) -> Result<super::super::super::schema::session::login::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_session__login = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Session_Login(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Session_Login)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync,
            {
                fn handle(&self, root: super::super::super::protocol::Client, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Session_Login(_) => self.on_session__login.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::server::Client { root },
                        params,
                    };
                    slot(call)
                }
            }
        }

    }
    pub mod client {
        pub struct Client {
            root: super::super::protocol::Client,
        }

        impl Client {
            pub fn new(root: super::super::protocol::Client) -> Self {
                Self { root }
            }
            pub fn get_cookies(&self, p: super::super::schema::get_cookies::Params) -> Result<super::super::schema::get_cookies::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::GetCookies(p),
                    |r| match r {
                        super::super::protocol::Results::GetCookies(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn reverse(&self, p: super::super::schema::reverse::Params) -> Result<super::super::schema::reverse::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::Reverse(p),
                    |r| match r {
                        super::super::protocol::Results::Reverse(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn ping(&self, p: super::super::schema::ping::Params) -> Result<super::super::schema::ping::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::Ping(p),
                    |r| match r {
                        super::super::protocol::Results::Ping(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn new_york(&self, p: super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                    |r| match r {
                        super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn login(&self, p: super::super::schema::session::login::Params) -> Result<super::super::schema::session::login::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::Session_Login(p),
                    |r| match r {
                        super::super::protocol::Results::Session_Login(r) => Some(r),
                        _ => None,
                    }
                )
            }
        }
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::client::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
        }
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub type Slot<T> = Option<Box<SlotFn<T>>>;
        pub struct Handler<T> {
            state: std::sync::Arc<T>,
            on_get_user_agent: Slot<T>,
        }

        impl<T> Handler<T> {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    on_get_user_agent: None,
                }
            }
            pub fn on_get_user_agent<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::get_user_agent::Params>) -> Result<super::super::schema::get_user_agent::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_get_user_agent = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::GetUserAgent(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::GetUserAgent)
                    }
                ));
            }
        }
        impl<T> ::lavish::Handler<super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Handler<T>
        where
            T: Send + Sync,
        {
            fn handle(&self, root: super::super::protocol::Client, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                let slot = match params {
                    super::super::protocol::Params::GetUserAgent(_) => self.on_get_user_agent.as_ref(),
                    _ => None,
                }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::client::Client { root },
                    params,
                };
                slot(call)
            }
        }
    }

    pub mod server {
        pub struct Client {
            root: super::super::protocol::Client,
        }

        impl Client {
            pub fn new(root: super::super::protocol::Client) -> Self {
                Self { root }
            }
            pub fn get_user_agent(&self, p: super::super::schema::get_user_agent::Params) -> Result<super::super::schema::get_user_agent::Results, ::lavish::Error> {
                self.root.call(
                    super::super::protocol::Params::GetUserAgent(p),
                    |r| match r {
                        super::super::protocol::Results::GetUserAgent(r) => Some(r),
                        _ => None,
                    }
                )
            }
        }
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::server::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
        }
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub type Slot<T> = Option<Box<SlotFn<T>>>;
        pub struct Handler<T> {
            state: std::sync::Arc<T>,
            on_get_cookies: Slot<T>,
            on_reverse: Slot<T>,
            on_ping: Slot<T>,
            on_universe__earth__country__city__new_york: Slot<T>,
            on_session__login: Slot<T>,
        }

        impl<T> Handler<T>
        where T: Send + Sync + 'static {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    on_get_cookies: None,
                    on_reverse: None,
                    on_ping: None,
                    on_universe__earth__country__city__new_york: None,
                    on_session__login: None,
                }
            }
            pub fn connect<C>(self, conn: C) -> Result<Client, lavish::Error>
            where C: lavish::Conn {
                Ok(Client::new(lavish::connect(super::super::protocol::protocol(), self, conn)?))
            }
            pub fn on_get_cookies<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::get_cookies::Params>) -> Result<super::super::schema::get_cookies::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_get_cookies = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::GetCookies(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::GetCookies)
                    }
                ));
            }
            pub fn on_reverse<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::reverse::Params>) -> Result<super::super::schema::reverse::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_reverse = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Reverse(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Reverse)
                    }
                ));
            }
            pub fn on_ping<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::ping::Params>) -> Result<super::super::schema::ping::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_ping = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Ping(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Ping)
                    }
                ));
            }
            pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_universe__earth__country__city__new_york = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                    }
                ));
            }
            pub fn on_session__login<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::session::login::Params>) -> Result<super::super::schema::session::login::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_session__login = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Session_Login(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Session_Login)
                    }
                ));
            }
        }
        impl<T> ::lavish::Handler<super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Handler<T>
        where
            T: Send + Sync,
        {
            fn handle(&self, root: super::super::protocol::Client, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                let slot = match params {
                    super::super::protocol::Params::GetCookies(_) => self.on_get_cookies.as_ref(),
                    super::super::protocol::Params::Reverse(_) => self.on_reverse.as_ref(),
                    super::super::protocol::Params::Ping(_) => self.on_ping.as_ref(),
                    super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                    super::super::protocol::Params::Session_Login(_) => self.on_session__login.as_ref(),
                    _ => None,
                }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::server::Client { root },
                    params,
                };
                slot(call)
            }
        }
    }

}
