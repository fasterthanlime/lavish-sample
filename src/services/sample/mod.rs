// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(clippy::all, unknown_lints, unused, non_snake_case)]

pub mod protocol {
    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Params {
        GetCookies(super::schema::get_cookies::Params),
        Reverse(super::schema::reverse::Params),
        GetUserAgent(super::schema::get_user_agent::Params),
        Ping_Ping(super::schema::ping::ping::Params),
        Ping(super::schema::ping::Params),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Params),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Params),
        Session_Login(super::schema::session::login::Params),
    }
    impl ::lavish::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::GetCookies(_) => "get_cookies",
                Params::Reverse(_) => "reverse",
                Params::GetUserAgent(_) => "get_user_agent",
                Params::Ping_Ping(_) => "ping.ping",
                Params::Ping(_) => "ping",
                Params::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Params::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Params::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Params::GetCookies(__DS::<super::schema::get_cookies::Params>(de)?)),
                "reverse" => 
                    Ok(Params::Reverse(__DS::<super::schema::reverse::Params>(de)?)),
                "get_user_agent" => 
                    Ok(Params::GetUserAgent(__DS::<super::schema::get_user_agent::Params>(de)?)),
                "ping.ping" => 
                    Ok(Params::Ping_Ping(__DS::<super::schema::ping::ping::Params>(de)?)),
                "ping" => 
                    Ok(Params::Ping(__DS::<super::schema::ping::Params>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Params::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Params>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Params::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Params>(de)?)),
                "session.login" => 
                    Ok(Params::Session_Login(__DS::<super::schema::session::login::Params>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Results {
        GetCookies(super::schema::get_cookies::Results),
        Reverse(super::schema::reverse::Results),
        GetUserAgent(super::schema::get_user_agent::Results),
        Ping_Ping(super::schema::ping::ping::Results),
        Ping(super::schema::ping::Results),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Results),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Results),
        Session_Login(super::schema::session::login::Results),
    }
    impl ::lavish::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::GetCookies(_) => "get_cookies",
                Results::Reverse(_) => "reverse",
                Results::GetUserAgent(_) => "get_user_agent",
                Results::Ping_Ping(_) => "ping.ping",
                Results::Ping(_) => "ping",
                Results::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Results::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Results::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Results::GetCookies(__DS::<super::schema::get_cookies::Results>(de)?)),
                "reverse" => 
                    Ok(Results::Reverse(__DS::<super::schema::reverse::Results>(de)?)),
                "get_user_agent" => 
                    Ok(Results::GetUserAgent(__DS::<super::schema::get_user_agent::Results>(de)?)),
                "ping.ping" => 
                    Ok(Results::Ping_Ping(__DS::<super::schema::ping::ping::Results>(de)?)),
                "ping" => 
                    Ok(Results::Ping(__DS::<super::schema::ping::Results>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Results::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Results>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Results::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Results>(de)?)),
                "session.login" => 
                    Ok(Results::Session_Login(__DS::<super::schema::session::login::Results>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum NotificationParams {}
    impl ::lavish::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            panic!("no variants for NotificationParams")
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

}

pub mod schema {
    #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
    pub struct Cookie {
        key: String,
        value: String,
    }
    pub mod get_cookies {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            cookies: Vec<super::Cookie>,
        }
    }
    pub mod reverse {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
            s: String,
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            s: String,
        }
    }
    pub mod get_user_agent {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            user_agent: String,
        }
    }
    pub mod ping {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
        }

        pub mod ping {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }
        }
        pub struct Client {
            ping__ping: (),
            // TODO
        }

        pub struct Call<T, PP> {
            pub state: ::std::sync::Arc<T>,
            pub client: Client,
            pub params: PP,
        }

        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(::std::sync::Arc<T>, Client, super::super::protocol::Params) -> SlotReturn + 'static + Send + Sync;
        pub type Slot<T> = Option<Box<SlotFn<T>>>;
        pub struct Handler<T> {
            state: std::sync::Arc<T>,
        }

    }
    pub mod universe {
        pub mod earth {
            pub mod country {
                pub mod city {
                    pub mod new_york {
                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Params {
                        }

                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Results {
                        }
                    }
                }
            }
        }
    }
    pub mod session {
        pub mod login {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
                username: String,
                password: String,
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }

            pub mod solve_totp {
                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Params {
                }

                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Results {
                    result: String,
                }
            }
            pub struct Client {
                session__login__solve_totp: (),
                // TODO
            }

            pub struct Call<T, PP> {
                pub state: ::std::sync::Arc<T>,
                pub client: Client,
                pub params: PP,
            }

            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(::std::sync::Arc<T>, Client, super::super::super::protocol::Params) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T> {
                state: std::sync::Arc<T>,
            }

        }
    }
}

pub mod client {
    pub struct Client {
        get_cookies: (),
        reverse: (),
        ping: (),
        universe__earth__country__city__new_york: (),
        session__login: (),
        // TODO
    }

    pub struct Call<T, PP> {
        pub state: ::std::sync::Arc<T>,
        pub client: Client,
        pub params: PP,
    }

    pub type SlotReturn = Result<super::protocol::Results, ::lavish::Error>;
    pub type SlotFn<T> = Fn(::std::sync::Arc<T>, Client, super::protocol::Params) -> SlotReturn + 'static + Send + Sync;
    pub type Slot<T> = Option<Box<SlotFn<T>>>;
    pub struct Handler<T> {
        state: std::sync::Arc<T>,
        on_get_user_agent: Slot<T>,
    }

}

pub mod server {
    pub struct Client {
        get_user_agent: (),
        // TODO
    }

    pub struct Call<T, PP> {
        pub state: ::std::sync::Arc<T>,
        pub client: Client,
        pub params: PP,
    }

    pub type SlotReturn = Result<super::protocol::Results, ::lavish::Error>;
    pub type SlotFn<T> = Fn(::std::sync::Arc<T>, Client, super::protocol::Params) -> SlotReturn + 'static + Send + Sync;
    pub type Slot<T> = Option<Box<SlotFn<T>>>;
    pub struct Handler<T> {
        state: std::sync::Arc<T>,
        on_get_cookies: Slot<T>,
        on_reverse: Slot<T>,
        on_ping: Slot<T>,
        on_universe__earth__country__city__new_york: Slot<T>,
        on_session__login: Slot<T>,
    }

}
