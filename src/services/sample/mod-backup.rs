// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(clippy::all, unknown_lints, unused, non_snake_case)]

pub use schema::*;

pub mod protocol {
    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Params {
        GetCookies(super::schema::get_cookies::Params),
        Reverse(super::schema::reverse::Params),
        GetUserAgent(super::schema::get_user_agent::Params),
        Ping_Ping(super::schema::ping::ping::Params),
        Ping(super::schema::ping::Params),
        Cookies_Get(super::schema::cookies::get::Params),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Params),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Params),
        Session_Login(super::schema::session::login::Params),
    }
    impl ::lavish::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::GetCookies(_) => "get_cookies",
                Params::Reverse(_) => "reverse",
                Params::GetUserAgent(_) => "get_user_agent",
                Params::Ping_Ping(_) => "ping.ping",
                Params::Ping(_) => "ping",
                Params::Cookies_Get(_) => "cookies.get",
                Params::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Params::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Params::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Params::GetCookies(__DS::<super::schema::get_cookies::Params>(de)?)),
                "reverse" => 
                    Ok(Params::Reverse(__DS::<super::schema::reverse::Params>(de)?)),
                "get_user_agent" => 
                    Ok(Params::GetUserAgent(__DS::<super::schema::get_user_agent::Params>(de)?)),
                "ping.ping" => 
                    Ok(Params::Ping_Ping(__DS::<super::schema::ping::ping::Params>(de)?)),
                "ping" => 
                    Ok(Params::Ping(__DS::<super::schema::ping::Params>(de)?)),
                "cookies.get" => 
                    Ok(Params::Cookies_Get(__DS::<super::schema::cookies::get::Params>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Params::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Params>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Params::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Params>(de)?)),
                "session.login" => 
                    Ok(Params::Session_Login(__DS::<super::schema::session::login::Params>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum Results {
        GetCookies(super::schema::get_cookies::Results),
        Reverse(super::schema::reverse::Results),
        GetUserAgent(super::schema::get_user_agent::Results),
        Ping_Ping(super::schema::ping::ping::Results),
        Ping(super::schema::ping::Results),
        Cookies_Get(super::schema::cookies::get::Results),
        Universe_Earth_Country_City_NewYork(super::schema::universe::earth::country::city::new_york::Results),
        Session_Login_SolveTotp(super::schema::session::login::solve_totp::Results),
        Session_Login(super::schema::session::login::Results),
    }
    impl ::lavish::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::GetCookies(_) => "get_cookies",
                Results::Reverse(_) => "reverse",
                Results::GetUserAgent(_) => "get_user_agent",
                Results::Ping_Ping(_) => "ping.ping",
                Results::Ping(_) => "ping",
                Results::Cookies_Get(_) => "cookies.get",
                Results::Universe_Earth_Country_City_NewYork(_) => "universe.earth.country.city.new_york",
                Results::Session_Login_SolveTotp(_) => "session.login.solve_totp",
                Results::Session_Login(_) => "session.login",
            }
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                "get_cookies" => 
                    Ok(Results::GetCookies(__DS::<super::schema::get_cookies::Results>(de)?)),
                "reverse" => 
                    Ok(Results::Reverse(__DS::<super::schema::reverse::Results>(de)?)),
                "get_user_agent" => 
                    Ok(Results::GetUserAgent(__DS::<super::schema::get_user_agent::Results>(de)?)),
                "ping.ping" => 
                    Ok(Results::Ping_Ping(__DS::<super::schema::ping::ping::Results>(de)?)),
                "ping" => 
                    Ok(Results::Ping(__DS::<super::schema::ping::Results>(de)?)),
                "cookies.get" => 
                    Ok(Results::Cookies_Get(__DS::<super::schema::cookies::get::Results>(de)?)),
                "universe.earth.country.city.new_york" => 
                    Ok(Results::Universe_Earth_Country_City_NewYork(__DS::<super::schema::universe::earth::country::city::new_york::Results>(de)?)),
                "session.login.solve_totp" => 
                    Ok(Results::Session_Login_SolveTotp(__DS::<super::schema::session::login::solve_totp::Results>(de)?)),
                "session.login" => 
                    Ok(Results::Session_Login(__DS::<super::schema::session::login::Results>(de)?)),
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    #[derive(Debug, ::lavish::serde_derive::Serialize)]
    #[allow(non_camel_case_types, unused)]
    #[serde(untagged)]
    pub enum NotificationParams {}
    impl ::lavish::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            panic!("no variants for NotificationParams")
        }
        fn deserialize(method: &str, de: &mut ::lavish::erased_serde::Deserializer) -> ::lavish::erased_serde::Result<Self> {
            use ::lavish::erased_serde::deserialize as __DS;
            use ::lavish::serde::de::Error;

            match method {
                _ =>
                    Err(::lavish::erased_serde::Error::custom(format!("unknown method: {}", method))),
            }
        }
    }

    pub type Caller = ::lavish::Caller<super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;
    pub type Handler<CL> = ::lavish::Handler<CL, super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;

    pub trait Callable<R> {
        fn upcast_params(self) -> Params;
        fn downcast_results(results: Results) -> Option<R>;
    }

    pub trait Implementable<P> {
        fn method() -> &'static str;
        fn downcast_params(params: Params) -> Option<P>;
        fn upcast_results(self) -> Results;
    }

    #[derive(Clone, Copy)]
    pub struct Slottable<P, R>
    where R: Implementable<P> {
        pub phantom: std::marker::PhantomData<(P, R)>,
    }
}

pub mod schema {
    #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
    pub struct Cookie {
        /// The key of the cookie
        pub key: String,
        /// The value of the cookie.
        /// Although it's typed as a string, it can be anything underneath.
        pub value: String,
    }
    pub mod get_cookies {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub cookies: Vec<super::Cookie>,
        }

        use super::super::protocol;
        impl protocol::Callable<Results> for Params {
            fn upcast_params(self) -> protocol::Params {
                protocol::Params::GetCookies(self)
            }

            fn downcast_results(results: protocol::Results) -> Option<Results> {
                match results {
                    protocol::Results::GetCookies(r) => Some(r),
                    _ => None,
                }
            }
        }

        impl protocol::Implementable<Params> for Results {
            fn upcast_results(self) -> protocol::Results {
                protocol::Results::GetCookies(self)
            }

            fn downcast_params(params: protocol::Params) -> Option<Params> {
                match params {
                    protocol::Params::GetCookies(p) => Some(p),
                    _ => None,
                }
            }

            fn method() -> &'static str {
                "get_cookies"
            }
        }
    }
    pub mod reverse {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
            pub s: String,
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub s: String,
        }
    }

    use super::protocol;
    pub fn get_user_agent() -> protocol::Slottable<get_user_agent::Params, get_user_agent::Results> {
        protocol::Slottable { phantom: std::marker::PhantomData }
    }
    pub mod get_user_agent {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
            pub user_agent: String,
        }

        use super::super::protocol;
        impl protocol::Implementable<Params> for Results {
            fn upcast_results(self) -> protocol::Results {
                protocol::Results::GetUserAgent(self)
            }

            fn downcast_params(params: protocol::Params) -> Option<Params> {
                match params {
                    protocol::Params::GetUserAgent(p) => Some(p),
                    _ => None,
                }
            }

            fn method() -> &'static str {
                "get_user_agent"
            }
        }
    }
    pub mod ping {
        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Params {
        }

        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
        pub struct Results {
        }

        pub mod ping {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }
        }
    }
    pub mod cookies {
        pub mod get {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
                pub cookies: Vec<super::super::Cookie>,
            }
        }
        pub mod client {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            use super::super::super::protocol::Callable;
            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
                pub fn cookies__get(&self, p: super::super::super::schema::cookies::get::Params) -> Result<super::super::super::schema::cookies::get::Results, ::lavish::Error> {
                    self.caller.call(
                        super::super::super::protocol::Params::Cookies_Get(p),
                        |r| match r {
                            super::super::super::protocol::Results::Cookies_Get(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

        pub mod server {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
                on_cookies__get: Slot<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_cookies__get: None,
                    }
                }
                pub fn on_cookies__get<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::cookies::get::Params>) -> Result<super::super::super::schema::cookies::get::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_cookies__get = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Cookies_Get(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Cookies_Get)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Cookies_Get(_) => self.on_cookies__get.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::server::Client { caller },
                        params,
                    };
                    slot(call)
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

    }
    pub mod universe {
        pub mod earth {
            pub mod country {
                pub mod city {
                    pub mod new_york {
                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Params {
                        }

                        #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                        pub struct Results {
                        }
                    }
                    pub mod client {
                        #[derive(Clone)]
                        pub struct Client {
                            caller: super::super::super::super::super::super::protocol::Caller,
                        }

                        impl Client {
                            pub fn new(caller: super::super::super::super::super::super::protocol::Caller) -> Self {
                                Self { caller }
                            }
                            pub fn universe__earth__country__city__new_york(&self, p: super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                                self.caller.call(
                                    super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                                    |r| match r {
                                        super::super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                        _ => None,
                                    }
                                )
                            }
                        }
                        pub type Runtime = ::lavish::Runtime<Client>;
                        pub struct Call<T, P> {
                            pub state: ::std::sync::Arc<T>,
                            pub client: super::client::Client,
                            pub params: P,
                        }

                        impl<T, P> Call<T, P> {
                            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                            where
                                F: Fn(P) -> Option<PP>,
                            {
                                Ok(Call {
                                    state: self.state,
                                    client: self.client,
                                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                                })
                            }
                            pub fn shutdown_runtime(&self) {
                                self.client.caller.shutdown_runtime();
                            }
                        }
                        pub type SlotReturn = Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error>;
                        pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                        pub type Slot<T> = Option<Box<SlotFn<T>>>;
                        pub struct Handler<T>
                        where
                            T: Send + Sync + 'static
                        {
                            state: std::sync::Arc<T>,
                        }

                        impl<T> Handler<T>
                        where
                            T: Send + Sync + 'static,
                        {
                            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                                Self {
                                    state,
                                }
                            }
                        }
                        impl<T> ::lavish::Handler<Client, super::super::super::super::super::super::protocol::Params, super::super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::super::protocol::Results> for Handler<T>
                        where
                            T: Send + Sync + 'static,
                        {
                            fn handle(&self, caller: super::super::super::super::super::super::protocol::Caller, params: super::super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error> {
                                use ::lavish::Atom;
                                Err(::lavish::Error::MethodUnimplemented(params.method()))
                            }
                            fn make_client(caller: super::super::super::super::super::super::protocol::Caller) -> Client {
                                Client { caller }
                            }
                        }
                    }

                    pub mod server {
                        #[derive(Clone)]
                        pub struct Client {
                            caller: super::super::super::super::super::super::protocol::Caller,
                        }

                        impl Client {
                            pub fn new(caller: super::super::super::super::super::super::protocol::Caller) -> Self {
                                Self { caller }
                            }
                        }
                        pub type Runtime = ::lavish::Runtime<Client>;
                        pub struct Call<T, P> {
                            pub state: ::std::sync::Arc<T>,
                            pub client: super::server::Client,
                            pub params: P,
                        }

                        impl<T, P> Call<T, P> {
                            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                            where
                                F: Fn(P) -> Option<PP>,
                            {
                                Ok(Call {
                                    state: self.state,
                                    client: self.client,
                                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                                })
                            }
                            pub fn shutdown_runtime(&self) {
                                self.client.caller.shutdown_runtime();
                            }
                        }
                        pub type SlotReturn = Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error>;
                        pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                        pub type Slot<T> = Option<Box<SlotFn<T>>>;
                        pub struct Handler<T>
                        where
                            T: Send + Sync + 'static
                        {
                            state: std::sync::Arc<T>,
                            on_universe__earth__country__city__new_york: Slot<T>,
                        }

                        impl<T> Handler<T>
                        where
                            T: Send + Sync + 'static,
                        {
                            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                                Self {
                                    state,
                                    on_universe__earth__country__city__new_york: None,
                                }
                            }
                            pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                            where
                                F: Fn(Call<T, super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                            {
                                self.on_universe__earth__country__city__new_york = Some(Box::new(
                                    move |call| {
                                        let call = call.downcast(|p| match p {
                                            super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                            _ => None,
                                        })?;
                                        f(call).map(super::super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                                    }
                                ));
                            }
                        }
                        impl<T> ::lavish::Handler<Client, super::super::super::super::super::super::protocol::Params, super::super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::super::protocol::Results> for Handler<T>
                        where
                            T: Send + Sync + 'static,
                        {
                            fn handle(&self, caller: super::super::super::super::super::super::protocol::Caller, params: super::super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::super::protocol::Results, ::lavish::Error> {
                                use ::lavish::Atom;
                                let slot = match params {
                                    super::super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                                    _ => None,
                                }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                                let call = Call {
                                    state: self.state.clone(),
                                    client: super::server::Client { caller },
                                    params,
                                };
                                slot(call)
                            }
                            fn make_client(caller: super::super::super::super::super::super::protocol::Caller) -> Client {
                                Client { caller }
                            }
                        }
                    }

                }
                pub mod client {
                    #[derive(Clone)]
                    pub struct Client {
                        caller: super::super::super::super::super::protocol::Caller,
                    }

                    impl Client {
                        pub fn new(caller: super::super::super::super::super::protocol::Caller) -> Self {
                            Self { caller }
                        }
                        pub fn universe__earth__country__city__new_york(&self, p: super::super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                            self.caller.call(
                                super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                                |r| match r {
                                    super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                    _ => None,
                                }
                            )
                        }
                    }
                    pub type Runtime = ::lavish::Runtime<Client>;
                    pub struct Call<T, P> {
                        pub state: ::std::sync::Arc<T>,
                        pub client: super::client::Client,
                        pub params: P,
                    }

                    impl<T, P> Call<T, P> {
                        fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                        where
                            F: Fn(P) -> Option<PP>,
                        {
                            Ok(Call {
                                state: self.state,
                                client: self.client,
                                params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                            })
                        }
                        pub fn shutdown_runtime(&self) {
                            self.client.caller.shutdown_runtime();
                        }
                    }
                    pub type SlotReturn = Result<super::super::super::super::super::protocol::Results, ::lavish::Error>;
                    pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                    pub type Slot<T> = Option<Box<SlotFn<T>>>;
                    pub struct Handler<T>
                    where
                        T: Send + Sync + 'static
                    {
                        state: std::sync::Arc<T>,
                    }

                    impl<T> Handler<T>
                    where
                        T: Send + Sync + 'static,
                    {
                        pub fn new(state: ::std::sync::Arc<T>) -> Self {
                            Self {
                                state,
                            }
                        }
                    }
                    impl<T> ::lavish::Handler<Client, super::super::super::super::super::protocol::Params, super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::protocol::Results> for Handler<T>
                    where
                        T: Send + Sync + 'static,
                    {
                        fn handle(&self, caller: super::super::super::super::super::protocol::Caller, params: super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::protocol::Results, ::lavish::Error> {
                            use ::lavish::Atom;
                            Err(::lavish::Error::MethodUnimplemented(params.method()))
                        }
                        fn make_client(caller: super::super::super::super::super::protocol::Caller) -> Client {
                            Client { caller }
                        }
                    }
                }

                pub mod server {
                    #[derive(Clone)]
                    pub struct Client {
                        caller: super::super::super::super::super::protocol::Caller,
                    }

                    impl Client {
                        pub fn new(caller: super::super::super::super::super::protocol::Caller) -> Self {
                            Self { caller }
                        }
                    }
                    pub type Runtime = ::lavish::Runtime<Client>;
                    pub struct Call<T, P> {
                        pub state: ::std::sync::Arc<T>,
                        pub client: super::server::Client,
                        pub params: P,
                    }

                    impl<T, P> Call<T, P> {
                        fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                        where
                            F: Fn(P) -> Option<PP>,
                        {
                            Ok(Call {
                                state: self.state,
                                client: self.client,
                                params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                            })
                        }
                        pub fn shutdown_runtime(&self) {
                            self.client.caller.shutdown_runtime();
                        }
                    }
                    pub type SlotReturn = Result<super::super::super::super::super::protocol::Results, ::lavish::Error>;
                    pub type SlotFn<T> = Fn(Call<T, super::super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                    pub type Slot<T> = Option<Box<SlotFn<T>>>;
                    pub struct Handler<T>
                    where
                        T: Send + Sync + 'static
                    {
                        state: std::sync::Arc<T>,
                        on_universe__earth__country__city__new_york: Slot<T>,
                    }

                    impl<T> Handler<T>
                    where
                        T: Send + Sync + 'static,
                    {
                        pub fn new(state: ::std::sync::Arc<T>) -> Self {
                            Self {
                                state,
                                on_universe__earth__country__city__new_york: None,
                            }
                        }
                        pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                        where
                            F: Fn(Call<T, super::super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                        {
                            self.on_universe__earth__country__city__new_york = Some(Box::new(
                                move |call| {
                                    let call = call.downcast(|p| match p {
                                        super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                        _ => None,
                                    })?;
                                    f(call).map(super::super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                                }
                            ));
                        }
                    }
                    impl<T> ::lavish::Handler<Client, super::super::super::super::super::protocol::Params, super::super::super::super::super::protocol::NotificationParams, super::super::super::super::super::protocol::Results> for Handler<T>
                    where
                        T: Send + Sync + 'static,
                    {
                        fn handle(&self, caller: super::super::super::super::super::protocol::Caller, params: super::super::super::super::super::protocol::Params) -> Result<super::super::super::super::super::protocol::Results, ::lavish::Error> {
                            use ::lavish::Atom;
                            let slot = match params {
                                super::super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                                _ => None,
                            }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                            let call = Call {
                                state: self.state.clone(),
                                client: super::server::Client { caller },
                                params,
                            };
                            slot(call)
                        }
                        fn make_client(caller: super::super::super::super::super::protocol::Caller) -> Client {
                            Client { caller }
                        }
                    }
                }

            }
            pub mod client {
                #[derive(Clone)]
                pub struct Client {
                    caller: super::super::super::super::protocol::Caller,
                }

                impl Client {
                    pub fn new(caller: super::super::super::super::protocol::Caller) -> Self {
                        Self { caller }
                    }
                    pub fn universe__earth__country__city__new_york(&self, p: super::super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                        self.caller.call(
                            super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                            |r| match r {
                                super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                                _ => None,
                            }
                        )
                    }
                }
                pub type Runtime = ::lavish::Runtime<Client>;
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::client::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                    pub fn shutdown_runtime(&self) {
                        self.client.caller.shutdown_runtime();
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T>
                where
                    T: Send + Sync + 'static
                {
                    state: std::sync::Arc<T>,
                }

                impl<T> Handler<T>
                where
                    T: Send + Sync + 'static,
                {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                        }
                    }
                }
                impl<T> ::lavish::Handler<Client, super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync + 'static,
                {
                    fn handle(&self, caller: super::super::super::super::protocol::Caller, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        Err(::lavish::Error::MethodUnimplemented(params.method()))
                    }
                    fn make_client(caller: super::super::super::super::protocol::Caller) -> Client {
                        Client { caller }
                    }
                }
            }

            pub mod server {
                #[derive(Clone)]
                pub struct Client {
                    caller: super::super::super::super::protocol::Caller,
                }

                impl Client {
                    pub fn new(caller: super::super::super::super::protocol::Caller) -> Self {
                        Self { caller }
                    }
                }
                pub type Runtime = ::lavish::Runtime<Client>;
                pub struct Call<T, P> {
                    pub state: ::std::sync::Arc<T>,
                    pub client: super::server::Client,
                    pub params: P,
                }

                impl<T, P> Call<T, P> {
                    fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                    where
                        F: Fn(P) -> Option<PP>,
                    {
                        Ok(Call {
                            state: self.state,
                            client: self.client,
                            params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                        })
                    }
                    pub fn shutdown_runtime(&self) {
                        self.client.caller.shutdown_runtime();
                    }
                }
                pub type SlotReturn = Result<super::super::super::super::protocol::Results, ::lavish::Error>;
                pub type SlotFn<T> = Fn(Call<T, super::super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
                pub type Slot<T> = Option<Box<SlotFn<T>>>;
                pub struct Handler<T>
                where
                    T: Send + Sync + 'static
                {
                    state: std::sync::Arc<T>,
                    on_universe__earth__country__city__new_york: Slot<T>,
                }

                impl<T> Handler<T>
                where
                    T: Send + Sync + 'static,
                {
                    pub fn new(state: ::std::sync::Arc<T>) -> Self {
                        Self {
                            state,
                            on_universe__earth__country__city__new_york: None,
                        }
                    }
                    pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                    where
                        F: Fn(Call<T, super::super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                    {
                        self.on_universe__earth__country__city__new_york = Some(Box::new(
                            move |call| {
                                let call = call.downcast(|p| match p {
                                    super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                    _ => None,
                                })?;
                                f(call).map(super::super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                            }
                        ));
                    }
                }
                impl<T> ::lavish::Handler<Client, super::super::super::super::protocol::Params, super::super::super::super::protocol::NotificationParams, super::super::super::super::protocol::Results> for Handler<T>
                where
                    T: Send + Sync + 'static,
                {
                    fn handle(&self, caller: super::super::super::super::protocol::Caller, params: super::super::super::super::protocol::Params) -> Result<super::super::super::super::protocol::Results, ::lavish::Error> {
                        use ::lavish::Atom;
                        let slot = match params {
                            super::super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                            _ => None,
                        }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                        let call = Call {
                            state: self.state.clone(),
                            client: super::server::Client { caller },
                            params,
                        };
                        slot(call)
                    }
                    fn make_client(caller: super::super::super::super::protocol::Caller) -> Client {
                        Client { caller }
                    }
                }
            }

        }
        pub mod client {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
                pub fn universe__earth__country__city__new_york(&self, p: super::super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                    self.caller.call(
                        super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                        |r| match r {
                            super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

        pub mod server {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
                on_universe__earth__country__city__new_york: Slot<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_universe__earth__country__city__new_york: None,
                    }
                }
                pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_universe__earth__country__city__new_york = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::server::Client { caller },
                        params,
                    };
                    slot(call)
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

    }
    pub mod session {
        pub mod login {
            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Params {
                pub username: String,
                pub password: String,
            }

            #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
            pub struct Results {
            }

            pub mod solve_totp {
                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Params {
                }

                #[derive(Debug, ::lavish::serde_derive::Serialize, ::lavish::serde_derive::Deserialize)]
                pub struct Results {
                    pub result: String,
                }
            }
        }
        pub mod client {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
                pub fn session__login(&self, p: super::super::super::schema::session::login::Params) -> Result<super::super::super::schema::session::login::Results, ::lavish::Error> {
                    self.caller.call(
                        super::super::super::protocol::Params::Session_Login(p),
                        |r| match r {
                            super::super::super::protocol::Results::Session_Login(r) => Some(r),
                            _ => None,
                        }
                    )
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::client::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                    }
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    Err(::lavish::Error::MethodUnimplemented(params.method()))
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

        pub mod server {
            #[derive(Clone)]
            pub struct Client {
                caller: super::super::super::protocol::Caller,
            }

            impl Client {
                pub fn new(caller: super::super::super::protocol::Caller) -> Self {
                    Self { caller }
                }
            }
            pub type Runtime = ::lavish::Runtime<Client>;
            pub struct Call<T, P> {
                pub state: ::std::sync::Arc<T>,
                pub client: super::server::Client,
                pub params: P,
            }

            impl<T, P> Call<T, P> {
                fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
                where
                    F: Fn(P) -> Option<PP>,
                {
                    Ok(Call {
                        state: self.state,
                        client: self.client,
                        params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                    })
                }
                pub fn shutdown_runtime(&self) {
                    self.client.caller.shutdown_runtime();
                }
            }
            pub type SlotReturn = Result<super::super::super::protocol::Results, ::lavish::Error>;
            pub type SlotFn<T> = Fn(Call<T, super::super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
            pub type Slot<T> = Option<Box<SlotFn<T>>>;
            pub struct Handler<T>
            where
                T: Send + Sync + 'static
            {
                state: std::sync::Arc<T>,
                on_session__login: Slot<T>,
            }

            impl<T> Handler<T>
            where
                T: Send + Sync + 'static,
            {
                pub fn new(state: ::std::sync::Arc<T>) -> Self {
                    Self {
                        state,
                        on_session__login: None,
                    }
                }
                pub fn on_session__login<F>(&mut self, f: F)
                where
                    F: Fn(Call<T, super::super::super::schema::session::login::Params>) -> Result<super::super::super::schema::session::login::Results, ::lavish::Error> + Send + Sync + 'static,
                {
                    self.on_session__login = Some(Box::new(
                        move |call| {
                            let call = call.downcast(|p| match p {
                                super::super::super::protocol::Params::Session_Login(p) => Some(p),
                                _ => None,
                            })?;
                            f(call).map(super::super::super::protocol::Results::Session_Login)
                        }
                    ));
                }
            }
            impl<T> ::lavish::Handler<Client, super::super::super::protocol::Params, super::super::super::protocol::NotificationParams, super::super::super::protocol::Results> for Handler<T>
            where
                T: Send + Sync + 'static,
            {
                fn handle(&self, caller: super::super::super::protocol::Caller, params: super::super::super::protocol::Params) -> Result<super::super::super::protocol::Results, ::lavish::Error> {
                    use ::lavish::Atom;
                    let slot = match params {
                        super::super::super::protocol::Params::Session_Login(_) => self.on_session__login.as_ref(),
                        _ => None,
                    }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                    let call = Call {
                        state: self.state.clone(),
                        client: super::server::Client { caller },
                        params,
                    };
                    slot(call)
                }
                fn make_client(caller: super::super::super::protocol::Caller) -> Client {
                    Client { caller }
                }
            }
        }

    }
    pub mod client {
        #[derive(Clone)]
        pub struct Client {
            caller: super::super::protocol::Caller,
        }

        use super::super::protocol::{Callable, Slottable, Implementable};
        impl Client {
            pub fn new(caller: super::super::protocol::Caller) -> Self {
                Self { caller }
            }
            pub fn call<P, R>(&self, p: P) -> Result<R, lavish::Error>
            where P: Callable<R> {
                self.caller.call(
                    p.upcast_params(),
                    P::downcast_results,
                )
            }
            pub fn get_cookies(&self, p: super::super::schema::get_cookies::Params) -> Result<super::super::schema::get_cookies::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::GetCookies(p),
                    |r| match r {
                        super::super::protocol::Results::GetCookies(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn reverse(&self, p: super::super::schema::reverse::Params) -> Result<super::super::schema::reverse::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::Reverse(p),
                    |r| match r {
                        super::super::protocol::Results::Reverse(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn ping(&self, p: super::super::schema::ping::Params) -> Result<super::super::schema::ping::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::Ping(p),
                    |r| match r {
                        super::super::protocol::Results::Ping(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn cookies__get(&self, p: super::super::schema::cookies::get::Params) -> Result<super::super::schema::cookies::get::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::Cookies_Get(p),
                    |r| match r {
                        super::super::protocol::Results::Cookies_Get(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn universe__earth__country__city__new_york(&self, p: super::super::schema::universe::earth::country::city::new_york::Params) -> Result<super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p),
                    |r| match r {
                        super::super::protocol::Results::Universe_Earth_Country_City_NewYork(r) => Some(r),
                        _ => None,
                    }
                )
            }
            pub fn session__login(&self, p: super::super::schema::session::login::Params) -> Result<super::super::schema::session::login::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::Session_Login(p),
                    |r| match r {
                        super::super::protocol::Results::Session_Login(r) => Some(r),
                        _ => None,
                    }
                )
            }
        }
        pub type Runtime = ::lavish::Runtime<Client>;
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::client::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
            pub fn shutdown_runtime(&self) {
                self.client.caller.shutdown_runtime();
            }
        }
        use std::collections::HashMap;
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub type Slot<T> = Option<Box<SlotFn<T>>>;
        pub struct Handler<T>
        where
            T: Send + Sync + 'static
        {
            state: std::sync::Arc<T>,
            slots: HashMap<&'static str, Box<SlotFn<T>>>,
            on_get_user_agent: Slot<T>,
        }

        impl<T> Handler<T>
        where
            T: Send + Sync + 'static,
        {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    slots: HashMap::new(),
                    on_get_user_agent: None,
                }
            }
            pub fn on_get_user_agent<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::get_user_agent::Params>) -> Result<super::super::schema::get_user_agent::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_get_user_agent = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::GetUserAgent(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::GetUserAgent)
                    }
                ));
            }

            pub fn register<S, P, R, F>(&mut self, s: S, f: F)
            where
                S: Fn() -> Slottable<P, R>,
                R: Implementable<P>,
                F: Fn(Call<T, P>) -> Result<R, lavish::Error> + Send + Sync + 'static
            {
                self.slots.insert(R::method(), Box::new(move |call| {
                    let call = call.downcast(R::downcast_params)?;
                    f(call).map(|r| r.upcast_results())
                }));
            }
        }
        impl<T> ::lavish::Handler<Client, super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Handler<T>
        where
            T: Send + Sync + 'static,
        {
            fn handle(&self, caller: super::super::protocol::Caller, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                // let slot = match params {
                //     super::super::protocol::Params::GetUserAgent(_) => self.on_get_user_agent.as_ref(),
                //     _ => None,
                // }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let slot = self.slots.get(params.method()).ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::client::Client { caller },
                    params,
                };
                slot(call)
            }
            fn make_client(caller: super::super::protocol::Caller) -> Client {
                Client { caller }
            }
        }
    }

    pub mod server {
        #[derive(Clone)]
        pub struct Client {
            caller: super::super::protocol::Caller,
        }

        impl Client {
            pub fn new(caller: super::super::protocol::Caller) -> Self {
                Self { caller }
            }
            pub fn get_user_agent(&self, p: super::super::schema::get_user_agent::Params) -> Result<super::super::schema::get_user_agent::Results, ::lavish::Error> {
                self.caller.call(
                    super::super::protocol::Params::GetUserAgent(p),
                    |r| match r {
                        super::super::protocol::Results::GetUserAgent(r) => Some(r),
                        _ => None,
                    }
                )
            }
        }
        pub type Runtime = ::lavish::Runtime<Client>;
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::server::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
            pub fn shutdown_runtime(&self) {
                self.client.caller.shutdown_runtime();
            }
        }
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub type Slot<T> = Option<Box<SlotFn<T>>>;
        pub struct Handler<T>
        where
            T: Send + Sync + 'static
        {
            state: std::sync::Arc<T>,
            on_get_cookies: Slot<T>,
            on_reverse: Slot<T>,
            on_ping: Slot<T>,
            on_cookies__get: Slot<T>,
            on_universe__earth__country__city__new_york: Slot<T>,
            on_session__login: Slot<T>,
        }

        impl<T> Handler<T>
        where
            T: Send + Sync + 'static,
        {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    on_get_cookies: None,
                    on_reverse: None,
                    on_ping: None,
                    on_cookies__get: None,
                    on_universe__earth__country__city__new_york: None,
                    on_session__login: None,
                }
            }
            pub fn on_get_cookies<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::get_cookies::Params>) -> Result<super::super::schema::get_cookies::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_get_cookies = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::GetCookies(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::GetCookies)
                    }
                ));
            }
            pub fn on_reverse<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::reverse::Params>) -> Result<super::super::schema::reverse::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_reverse = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Reverse(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Reverse)
                    }
                ));
            }
            pub fn on_ping<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::ping::Params>) -> Result<super::super::schema::ping::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_ping = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Ping(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Ping)
                    }
                ));
            }
            pub fn on_cookies__get<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::cookies::get::Params>) -> Result<super::super::schema::cookies::get::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_cookies__get = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Cookies_Get(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Cookies_Get)
                    }
                ));
            }
            pub fn on_universe__earth__country__city__new_york<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::universe::earth::country::city::new_york::Params>) -> Result<super::super::schema::universe::earth::country::city::new_york::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_universe__earth__country__city__new_york = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Universe_Earth_Country_City_NewYork(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Universe_Earth_Country_City_NewYork)
                    }
                ));
            }
            pub fn on_session__login<F>(&mut self, f: F)
            where
                F: Fn(Call<T, super::super::schema::session::login::Params>) -> Result<super::super::schema::session::login::Results, ::lavish::Error> + Send + Sync + 'static,
            {
                self.on_session__login = Some(Box::new(
                    move |call| {
                        let call = call.downcast(|p| match p {
                            super::super::protocol::Params::Session_Login(p) => Some(p),
                            _ => None,
                        })?;
                        f(call).map(super::super::protocol::Results::Session_Login)
                    }
                ));
            }
        }
        impl<T> ::lavish::Handler<Client, super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Handler<T>
        where
            T: Send + Sync + 'static,
        {
            fn handle(&self, caller: super::super::protocol::Caller, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                let slot = match params {
                    super::super::protocol::Params::GetCookies(_) => self.on_get_cookies.as_ref(),
                    super::super::protocol::Params::Reverse(_) => self.on_reverse.as_ref(),
                    super::super::protocol::Params::Ping(_) => self.on_ping.as_ref(),
                    super::super::protocol::Params::Cookies_Get(_) => self.on_cookies__get.as_ref(),
                    super::super::protocol::Params::Universe_Earth_Country_City_NewYork(_) => self.on_universe__earth__country__city__new_york.as_ref(),
                    super::super::protocol::Params::Session_Login(_) => self.on_session__login.as_ref(),
                    _ => None,
                }.ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::server::Client { caller },
                    params,
                };
                slot(call)
            }
            fn make_client(caller: super::super::protocol::Caller) -> Client {
                Client { caller }
            }
        }
    }

}
