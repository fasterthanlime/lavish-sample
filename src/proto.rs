// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

// Kindly ask rustfmt not to reformat this file.
#![cfg_attr(rustfmt, rustfmt_skip)]

// Disable some lints, since this file is generated.
#![allow(clippy::all)]
#![allow(unknown_lints)]
#![allow(unused)]

pub use __::*;

mod __ {
    // Notes: as of 2019-05-21, futures-preview is required
    use futures::prelude::*;
    use std::pin::Pin;
    use std::sync::Arc;
    
    use lavish_rpc as rpc;
    use lavish_rpc::serde_derive::*;
    use lavish_rpc::erased_serde;
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Params {
        double_util_print(double::util::print::Params),
        double_double(double::double::Params),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Results {
        double_util_print(double::util::print::Results),
        double_double(double::double::Results),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum NotificationParams {
        double_util_log(double::util::log::Params),
    }
    
    pub type Message = rpc::Message<Params, NotificationParams, Results>;
    pub type Handle = rpc::Handle<Params, NotificationParams, Results>;
    pub type System = rpc::System<Params, NotificationParams, Results>;
    pub type Call<T, PP> = rpc::Call<T, Params, NotificationParams, Results, PP>;
    pub type MethodHandler<'a, T, PP, RR> = rpc::MethodHandler<'a, T, Params, NotificationParams, Results, PP, RR>;
    pub type Protocol = rpc::Protocol<Params, NotificationParams, Results>;
    pub type HandlerRet = Pin<Box<dyn Future<Output = Result<Results, rpc::Error>> + Send + 'static>>;
    
    pub fn protocol() -> Protocol {
        Protocol::new()
    }
    
    impl rpc::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::double_util_print(_) => "double.util.Print",
                Params::double_double(_) => "double.Double",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Print" =>
                    Ok(Params::double_util_print(deser::<double::util::print::Params>(de)?)),
                "double.Double" =>
                    Ok(Params::double_double(deser::<double::double::Params>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::double_util_print(_) => "double.util.Print",
                Results::double_double(_) => "double.Double",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Print" =>
                    Ok(Results::double_util_print(deser::<double::util::print::Results>(de)?)),
                "double.Double" =>
                    Ok(Results::double_double(deser::<double::double::Results>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            match self {
                NotificationParams::double_util_log(_) => "double.util.Log",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Log" =>
                    Ok(NotificationParams::double_util_log(deser::<double::util::log::Params>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    pub struct Handler<'a, T> {
        state: Arc<T>,
        double_util_print: MethodHandler<'a, T,
            double::util::print::Params, double::util::print::Results,
        >,
        double_double: MethodHandler<'a, T,
            double::double::Params, double::double::Results,
        >,
    }
    
    pub mod double {
        pub mod util {
            pub mod print {
                use lavish_rpc::serde_derive::*;
                use super::super::super::super::__;
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Params {
                    pub s: String,
                }
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Results {
                }
                
                impl Results {
                    pub fn downgrade(p: __::Results) -> Option<Self> {
                        match p {
                            __::Results::double_util_print(p) => Some(p),
                            _ => None,
                        }
                    }
                }
                
                pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                    h.call(
                        __::Params::double_util_print(p),
                        Results::downgrade,
                    ).await
                }
            }
            
            pub mod log {
                use lavish_rpc::serde_derive::*;
                use super::super::super::super::__;
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Params {
                    pub msg: String,
                }
            }
            
        }
        
        pub mod double {
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub x: i64,
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
                pub x: i64,
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::double_double(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::double_double(p),
                    Results::downgrade,
                ).await
            }
        }
        
    }
    
}
