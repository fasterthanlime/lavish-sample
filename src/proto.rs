// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

// Kindly ask rustfmt not to reformat this file.
#![cfg_attr(rustfmt, rustfmt_skip)]

// Disable some lints, since this file is generated.
#![allow(clippy::all)]
#![allow(unknown_lints)]
#![allow(unused)]

pub use __::*;

mod __ {
    // Notes: as of 2019-05-21, futures-preview is required
    use futures::prelude::*;
    use std::pin::Pin;
    use std::sync::Arc;
    
    use lavish_rpc as rpc;
    use rpc::{Atom, erased_serde, serde_derive::*};
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Params {
        sample_reverse(sample::reverse::Params),
        sample_print(sample::print::Params),
        sample_showstats(sample::show_stats::Params),
        sample_greet(sample::greet::Params),
        sample_getcookies(sample::get_cookies::Params),
        sample_reverselist(sample::reverse_list::Params),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Results {
        sample_reverse(sample::reverse::Results),
        sample_print(sample::print::Results),
        sample_showstats(sample::show_stats::Results),
        sample_greet(sample::greet::Results),
        sample_getcookies(sample::get_cookies::Results),
        sample_reverselist(sample::reverse_list::Results),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum NotificationParams {
    }
    
    pub type Message = rpc::Message<Params, NotificationParams, Results>;
    pub type Handle = rpc::Handle<Params, NotificationParams, Results>;
    pub type System = rpc::System<Params, NotificationParams, Results>;
    pub type Protocol = rpc::Protocol<Params, NotificationParams, Results>;
    
    pub fn protocol() -> Protocol {
        Protocol::new()
    }
    
    impl rpc::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::sample_reverse(_) => "sample.Reverse",
                Params::sample_print(_) => "sample.Print",
                Params::sample_showstats(_) => "sample.ShowStats",
                Params::sample_greet(_) => "sample.Greet",
                Params::sample_getcookies(_) => "sample.GetCookies",
                Params::sample_reverselist(_) => "sample.ReverseList",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "sample.Reverse" =>
                    Ok(Params::sample_reverse(deser::<sample::reverse::Params>(de)?)),
                "sample.Print" =>
                    Ok(Params::sample_print(deser::<sample::print::Params>(de)?)),
                "sample.ShowStats" =>
                    Ok(Params::sample_showstats(deser::<sample::show_stats::Params>(de)?)),
                "sample.Greet" =>
                    Ok(Params::sample_greet(deser::<sample::greet::Params>(de)?)),
                "sample.GetCookies" =>
                    Ok(Params::sample_getcookies(deser::<sample::get_cookies::Params>(de)?)),
                "sample.ReverseList" =>
                    Ok(Params::sample_reverselist(deser::<sample::reverse_list::Params>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::sample_reverse(_) => "sample.Reverse",
                Results::sample_print(_) => "sample.Print",
                Results::sample_showstats(_) => "sample.ShowStats",
                Results::sample_greet(_) => "sample.Greet",
                Results::sample_getcookies(_) => "sample.GetCookies",
                Results::sample_reverselist(_) => "sample.ReverseList",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "sample.Reverse" =>
                    Ok(Results::sample_reverse(deser::<sample::reverse::Results>(de)?)),
                "sample.Print" =>
                    Ok(Results::sample_print(deser::<sample::print::Results>(de)?)),
                "sample.ShowStats" =>
                    Ok(Results::sample_showstats(deser::<sample::show_stats::Results>(de)?)),
                "sample.Greet" =>
                    Ok(Results::sample_greet(deser::<sample::greet::Results>(de)?)),
                "sample.GetCookies" =>
                    Ok(Results::sample_getcookies(deser::<sample::get_cookies::Results>(de)?)),
                "sample.ReverseList" =>
                    Ok(Results::sample_reverselist(deser::<sample::reverse_list::Results>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            match self {
                _ => unimplemented!()
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    pub struct Call<T, PP> {
        pub state: Arc<T>,
        pub handle: Handle,
        pub params: PP,
    }
    
    pub type SlotFuture = 
        Future<Output = Result<Results, rpc::Error>> + Send + 'static;
    
    pub type SlotReturn = Pin<Box<SlotFuture>>;
    
    pub type SlotFn<'a, T> = 
        Fn(Arc<T>, Handle, Params) -> SlotReturn + 'a + Send + Sync;
    
    pub type Slot<'a, T> = Option<Box<SlotFn<'a, T>>>;
    
    pub struct Handler<'a, T> {
        state: Arc<T>,
        sample_reverse: Slot<'a, T>,
        sample_print: Slot<'a, T>,
        sample_showstats: Slot<'a, T>,
        sample_greet: Slot<'a, T>,
        sample_getcookies: Slot<'a, T>,
        sample_reverselist: Slot<'a, T>,
    }
    
    impl<'a, T> Handler<'a, T> {
        pub fn new(state: T) -> Self {
            Self {
                state: Arc::new(state),
                sample_reverse: None,
                sample_print: None,
                sample_showstats: None,
                sample_greet: None,
                sample_getcookies: None,
                sample_reverselist: None,
            }
        }
    }
    
    type HandlerRet = Pin<Box<dyn Future<Output = Result<Results, rpc::Error>> + Send + 'static>>;
    
    impl<'a, T> rpc::Handler<Params, NotificationParams, Results, HandlerRet> for Handler<'a, T>
    where
        T: Send + Sync,
    {
        fn handle(&self, handle: Handle, params: Params) -> HandlerRet {
            let method = params.method();
            let slot = match params {
                Params::sample_reverse(_) => self.sample_reverse.as_ref(),
                Params::sample_print(_) => self.sample_print.as_ref(),
                Params::sample_showstats(_) => self.sample_showstats.as_ref(),
                Params::sample_greet(_) => self.sample_greet.as_ref(),
                Params::sample_getcookies(_) => self.sample_getcookies.as_ref(),
                Params::sample_reverselist(_) => self.sample_reverselist.as_ref(),
                _ => None,
            };
            match slot {
                Some(slot_fn) => {
                    let res = slot_fn(self.state.clone(), handle, params);
                    Box::pin(async move { Ok(res.await?) })
                }
                None => Box::pin(async move { Err(rpc::Error::MethodUnimplemented(method)) }),
            }
        }
    }
    
    pub mod sample {
        pub mod reverse {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub s: String,
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_reverse(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
                pub s: String,
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_reverse(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_reverse(p),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<Results, lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_reverse = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(__::Results::sample_reverse)
                    )
                }));
            }
        }
        
        pub mod print {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub s: String,
                pub reversed: bool,
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_print(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_print(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_print(p),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<(), lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_print = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(|_| __::Results::sample_print(Results {}))
                    )
                }));
            }
        }
        
        pub mod show_stats {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_showstats(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_showstats(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: ()) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_showstats(Params {}),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<(), lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_showstats = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(|_| __::Results::sample_showstats(Results {}))
                    )
                }));
            }
        }
        
        pub mod greet {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub name: String,
                pub title: Option<String>,
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_greet(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_greet(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_greet(p),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<(), lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_greet = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(|_| __::Results::sample_greet(Results {}))
                    )
                }));
            }
        }
        
        pub mod get_cookies {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_getcookies(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
                pub cookies: ::std::collections::HashMap<String, String>,
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_getcookies(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: ()) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_getcookies(Params {}),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<Results, lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_getcookies = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(__::Results::sample_getcookies)
                    )
                }));
            }
        }
        
        pub mod reverse_list {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub input: Vec<String>,
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::sample_reverselist(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
                pub output: Vec<String>,
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::sample_reverselist(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::sample_reverselist(p),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<Results, lavish_rpc::Error>> + Send + 'static,
            {
                h.sample_reverselist = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(__::Results::sample_reverselist)
                    )
                }));
            }
        }
        
    }
    
}
