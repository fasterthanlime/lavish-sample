// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

// Kindly ask rustfmt not to reformat this file.
#![cfg_attr(rustfmt, rustfmt_skip)]

// Disable some lints, since this file is generated.
#![allow(clippy::all)]
#![allow(unknown_lints)]
#![allow(unused)]

pub use __::*;

mod __ {
    // Notes: as of 2019-05-21, futures-preview is required
    use futures::prelude::*;
    use std::pin::Pin;
    use std::sync::Arc;
    
    use lavish_rpc as rpc;
    use rpc::{Atom, erased_serde, serde_derive::*};
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Params {
        double_util_print(double::util::print::Params),
        double_double(double::double::Params),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum Results {
        double_util_print(double::util::print::Results),
        double_double(double::double::Results),
    }
    
    #[derive(Serialize, Debug)]
    #[serde(untagged)]
    #[allow(non_camel_case_types, unused)]
    pub enum NotificationParams {
        double_util_log(double::util::log::Params),
    }
    
    pub type Message = rpc::Message<Params, NotificationParams, Results>;
    pub type Handle = rpc::Handle<Params, NotificationParams, Results>;
    pub type System = rpc::System<Params, NotificationParams, Results>;
    pub type Protocol = rpc::Protocol<Params, NotificationParams, Results>;
    
    pub fn protocol() -> Protocol {
        Protocol::new()
    }
    
    impl rpc::Atom for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::double_util_print(_) => "double.util.Print",
                Params::double_double(_) => "double.Double",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Print" =>
                    Ok(Params::double_util_print(deser::<double::util::print::Params>(de)?)),
                "double.Double" =>
                    Ok(Params::double_double(deser::<double::double::Params>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::double_util_print(_) => "double.util.Print",
                Results::double_double(_) => "double.Double",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Print" =>
                    Ok(Results::double_util_print(deser::<double::util::print::Results>(de)?)),
                "double.Double" =>
                    Ok(Results::double_double(deser::<double::double::Results>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    impl rpc::Atom for NotificationParams {
        fn method(&self) -> &'static str {
            match self {
                NotificationParams::double_util_log(_) => "double.util.Log",
            }
        }
        
        fn deserialize(
            method: &str,
            de: &mut erased_serde::Deserializer,
        ) -> erased_serde::Result<Self> {
            use erased_serde::deserialize as deser;
            use serde::de::Error;
            
            match method {
                "double.util.Log" =>
                    Ok(NotificationParams::double_util_log(deser::<double::util::log::Params>(de)?)),
                _ => Err(erased_serde::Error::custom(format!(
                    "unknown method: {}",
                    method,
                ))),
            }
        }
    }
    
    pub struct Call<T, PP> {
        pub state: Arc<T>,
        pub handle: Handle,
        pub params: PP,
    }
    
    pub type SlotFuture = 
        Future<Output = Result<Results, rpc::Error>> + Send + 'static;
    
    pub type SlotReturn = Pin<Box<SlotFuture>>;
    
    pub type SlotFn<'a, T> = 
        Fn(Arc<T>, Handle, Params) -> SlotReturn + 'a + Send + Sync;
    
    pub type Slot<'a, T> = Option<Box<SlotFn<'a, T>>>;
    
    pub struct Handler<'a, T> {
        state: Arc<T>,
        double_util_print: Slot<'a, T>,
        double_double: Slot<'a, T>,
    }
    
    impl<'a, T> Handler<'a, T> {
        pub fn new(state: T) -> Self {
            Self {
                state: Arc::new(state),
                double_util_print: None,
                double_double: None,
            }
        }
    }
    
    type HandlerRet = Pin<Box<dyn Future<Output = Result<Results, rpc::Error>> + Send + 'static>>;
    
    impl<'a, T> rpc::Handler<Params, NotificationParams, Results, HandlerRet> for Handler<'a, T>
    where
        T: Send + Sync,
    {
        fn handle(&self, handle: Handle, params: Params) -> HandlerRet {
            let method = params.method();
            let slot = match params {
                Params::double_util_print(_) => self.double_util_print.as_ref(),
                Params::double_double(_) => self.double_double.as_ref(),
                _ => None,
            };
            match slot {
                Some(slot_fn) => {
                    let res = slot_fn(self.state.clone(), handle, params);
                    Box::pin(async move { Ok(res.await?) })
                }
                None => Box::pin(async move { Err(rpc::Error::MethodUnimplemented(method)) }),
            }
        }
    }
    
    pub mod double {
        pub mod util {
            pub mod print {
                use futures::prelude::*;
                use lavish_rpc::serde_derive::*;
                use super::super::super::super::__;
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Params {
                    pub s: String,
                }
                
                impl Params {
                    pub fn downgrade(p: __::Params) -> Option<Self> {
                        match p {
                            __::Params::double_util_print(p) => Some(p),
                            _ => None,
                        }
                    }
                }
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Results {
                }
                
                impl Results {
                    pub fn downgrade(p: __::Results) -> Option<Self> {
                        match p {
                            __::Results::double_util_print(p) => Some(p),
                            _ => None,
                        }
                    }
                }
                
                pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                    h.call(
                        __::Params::double_util_print(p),
                        Results::downgrade,
                    ).await
                }
                
                pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
                where
                    F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                    FT: Future<Output = Result<Results, lavish_rpc::Error>> + Send + 'static,
                {
                    h.double_util_print = Some(Box::new(move |state, handle, params| {
                        Box::pin(
                            f(__::Call {
                                state, handle,
                                params: Params::downgrade(params).unwrap(),
                            }).map_ok(__::Results::double_util_print)
                        )
                    }));
                }
            }
            
            pub mod log {
                use futures::prelude::*;
                use lavish_rpc::serde_derive::*;
                use super::super::super::super::__;
                
                #[derive(Serialize, Deserialize, Debug)]
                pub struct Params {
                    pub msg: String,
                }
                
                impl Params {
                    pub fn downgrade(p: __::NotificationParams) -> Option<Self> {
                        match p {
                            __::NotificationParams::double_util_log(p) => Some(p),
                            _ => None,
                        }
                    }
                }
            }
            
        }
        
        pub mod double {
            use futures::prelude::*;
            use lavish_rpc::serde_derive::*;
            use super::super::super::__;
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Params {
                pub x: i64,
            }
            
            impl Params {
                pub fn downgrade(p: __::Params) -> Option<Self> {
                    match p {
                        __::Params::double_double(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            #[derive(Serialize, Deserialize, Debug)]
            pub struct Results {
                pub x: i64,
            }
            
            impl Results {
                pub fn downgrade(p: __::Results) -> Option<Self> {
                    match p {
                        __::Results::double_double(p) => Some(p),
                        _ => None,
                    }
                }
            }
            
            pub async fn call(h: &__::Handle, p: Params) -> Result<Results, lavish_rpc::Error> {
                h.call(
                    __::Params::double_double(p),
                    Results::downgrade,
                ).await
            }
            
            pub fn register<'a, T, F, FT>(h: &mut __::Handler<'a, T>, f: F)
            where
                F: Fn(__::Call<T, Params>) -> FT + Sync + Send + 'a,
                FT: Future<Output = Result<Results, lavish_rpc::Error>> + Send + 'static,
            {
                h.double_double = Some(Box::new(move |state, handle, params| {
                    Box::pin(
                        f(__::Call {
                            state, handle,
                            params: Params::downgrade(params).unwrap(),
                        }).map_ok(__::Results::double_double)
                    )
                }));
            }
        }
        
    }
    
}
